# cython: cdivision=True
# cython: infer_types=True
# cython: profile=False
# cython: boundscheck=False
# cython: wraparound=False
# cython: nonecheck=False
# cython: initializedcheck=False
# cython: overflowcheck=False

""" Interface between bullet physics engine and muscle model. """

import pybullet as p
from physics_interface cimport PhysicsInterface
cimport numpy as cnp
from numpy cimport NPY_FLOAT
from libc.math cimport sqrt as csqrt
import numpy as np
import transformations as T
import farms_pylog as pylog 

cdef class BulletInterface(PhysicsInterface):
    """Interface between bullet physics engine and muscle model.
    """
    def __init__(self, model_id, lmtu, force, attachment_points):
        super(BulletInterface, self).__init__(lmtu, force, 'BULLET')
        #: Number of attachment_points
        self.model_id = model_id
        pylog.debug('Model {} -> num points {}'.format(
            self.model_id, len(attachment_points)))
        
        self.num_attachments = len(attachment_points)        

        self._points = cnp.ndarray((self.num_attachments,),
                                   dtype=[('p','(3,)f')])

        
        self.attachment_points = cnp.ndarray((self.num_attachments,),
                                            dtype=[('link_id','i'),
                                                   ('point','(4,)f')])
    
        
        #: Add the attachment_points
        self.add_attachment_points(attachment_points)

    #################### PY-FUNCTIONS ####################
    def add_attachment_points(self, attachment_points):
        """ Add new attachment point. 
        Parameters
        ----------
        attachment_points: <list>
            List containing link ids and attachment points
        """


        for j, attachment in enumerate(attachment_points):
            self.attachment_points[j][0] = attachment[0]
            self.attachment_points[j][1][0] = attachment[1][0]
            self.attachment_points[j][1][1] = attachment[1][1]
            self.attachment_points[j][1][2] = attachment[1][2]
            self.attachment_points[j][1][3] = 1.

        print(self.attachment_points)
        
    def py_dist_between_points(self, p1, p2):
        return self.c_dist_between_points(p1, p2)

    def py_force_vector(self, p1, p2, force, dir_vec):        
        return self.c_force_vector(p1, p2, force, dir_vec)
    
    #################### C-FUNCTIONS ####################
    cdef void c_compute_muscle_length(self):
        """ Compute the muscle length based on the physics simulator. """
        # cdef double[4] point
        cdef unsigned int _index = 0
        
        for link_id, point in self.attachment_points:
            if link_id == -1:
                (pos, orient) = p.getBasePositionAndOrientation(
                    self.model_id)
            else:
                (_, _, _, _, pos, orient, *_) = p.getLinkState(
                    self.model_id, link_id)
            trans = T.compose_matrix(angles=p.getEulerFromQuaternion(orient),
                             translate=pos)
            self._points[_index] = np.dot(trans, point)[:3]
            
        #: Compute the length
        cdef double _length = 0.0
        for j in range(self.num_attachments-1):
            _length += self.c_dist_between_points(
                self._points[_index], self.points[_index+j])
            
        pylog.debug('Length -> {}'.format(_length))

        #: Update the muscle length
        self.lmtu.c_set_value(_length)

    cdef inline double c_dist_between_points(self, double[:] p1, double[:] p2) nogil:
        """ Compute distance between two points. """
        cdef double dist = 0.
        
        for j in range(3):
            dist += (p1[j]-p2[j])*(p1[j]-p2[j])
        return csqrt(dist)

    cdef inline void c_force_vector(self, double[:] p1, double[:] p2, double force, double[:] f_vec) nogil:
        """ Compute the force vector between two given points. """

        for j in range(3):
            f_vec[j] = p1[j] - p2[j]

        #: Normalize
        cdef double mag = 0.0
        for j in range(3):
            mag += f_vec[j]*f_vec[j]

        for j in range(3):
            f_vec[j] = f_vec[j]*force/mag
        
    cdef void c_apply_muscle_forces(self):
        """ Apply the forces generated by the muscle onto the physical links. """
        cdef double _force = self.force.value
        cdef double[3] f_vec
        cdef cnp.ndarray dir_vec = np.zeros((3,))
        cdef int _link_id

        #: Apply forces
        for j in range(self.num_attachments - 1):
            #: link id
            _link_id = self.attachment_points[j][0]
            
            self.c_force_vector(
                self._points[j+1], self._points[j], _force, f_vec)
            
            #: To be checked
            if _link_id == -1:
                (pos, orient) = p.getBasePositionAndOrientation(
                    self.model_id)
            else:
                (_, _, _, _, pos, orient, *_) = p.getLinkState(
                    self.model_id, _link_id)
                
            trans = T.inverse_matrix(
                T.compose_matrix(angles=p.getEulerFromQuaternion(orient),
                                 translate=pos))
            f_vec = np.dot(trans, np.append(f_vec,[1]))[:3]

            #: Apply the force
            p.applyExternalForce(
                self.model_id, _link_id, f_vec, self._points[j],
                flags=p.LINK_FRAME)

        for j in range(1, self.num_attachments):
            #: link id
            _link_id = self.attachment_points[j][0]
            
            self.c_force_vector(
                self._points[j], self._points[j-1], _force, f_vec)
            
            #: To be checked
            if _link_id == -1:
                (pos, orient) = p.getBasePositionAndOrientation(
                    self.model_id)
            else:
                (_, _, _, _, pos, orient, *_) = p.getLinkState(
                    self.model_id, _link_id)
                
            trans = T.inverse_matrix(
                T.compose_matrix(angles=p.getEulerFromQuaternion(orient),
                                 translate=pos))
            f_vec = np.dot(trans, np.append(f_vec,[1]))[:3]

            #: Apply the force
            p.applyExternalForce(
                self.model_id, _link_id, f_vec, self._points[j],
                flags=p.LINK_FRAME)
